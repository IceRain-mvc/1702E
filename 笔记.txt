day01:

React简介:
  设计架构:MVC
  没有指令 手动
Vue
  设计架构:MVVM
  指令

脚手架:
  npx create-react-app 项目名字(小写)


jsx:  js+xml
xml:<div></div>
js :{解析js}  <解析xml>

jsx  虚拟DOM---> ReactDom.render() 渲染到页面上 真实DOM

React    : class 继承 Component
ReactDom : render :渲染 createElement() 创建虚拟Dom

api:

jsx  :  虚拟DOM

导出 --> 转成真实DOM

不提示:
  插件  jsx  下载量 10w+
  jsx


下午:
  React
  1:jsx  javascript  +  xml
    解析规则 {解析js}  <解析xml>

    render return(div)

    jsx  === 虚拟DOM  === react元素  div  id  > 哈哈哈

    对象 = React.createElement("div",{id:aaa},"哈哈哈")

  2:虚拟Dom转化成真实DOM

    <虚拟DOM /> 组件
    html  id root
    ReactDom.render(<虚拟DOM/>,document.getElementById("root"),()=>{})

创建一个组件
  1:创建一个js文件  class 继承 React.Component{
    render(){
        return (jsx)
    }
  }

  2:抛出
  3:使用页面 引入   <Day01 />

  组件之间的传值:
    父川子:
      vue:  :name = ""
            props:[]  {}
      react :  name  {...对象}
            this.props.name
    子传父:

day02:
  回顾:
  组件定义
    1:js
    import React,{Component} from 'react'
    2:class App extends Component{
        构造:super
        //vue  data
        this.state = {
            name:""
        }

        render(){
           jsx === 虚拟DOM === react元素
           {解析js  不能 if  fori}  <xml>
        }

        //...生命周期

    }

  组件传值
    父传子
     <Child name={"要传的值"} />
    子组件: this.props.name

  日考题:

  父传子
  子传父:
    vue:
      父组件 <child @childEmit="函数">  methods:{函数(参数){}}
      子组件 click(){
        this.$emit("childEmit",参数)
      }
    react:
      父组件
        1: <Child onHandleChild="函数">  父组件 函数(参数){}

      子组件
        2:this.props.onHandleChild("传值")

day03:
  6个
  回顾:
    组件 传值
      父传子
        <CHild name={}>  子组件 :this.props.name
      子传父
        <Child 事件={函数}/> 父组件 函数(参数){}
        子组件: this.props.事件("")
      非父子
        Context
        发布 订阅
      状态管理
        Redux
        MobX


  这节课:
    生命周期:
    为什么?
    做什么?
      项目 健壮
      优化代码
    react:
     16.8.6 : 新 旧
     新的生命周期

     旧的生命周期
        挂载   更新  销毁
        constructor:构造
          初始state
          绑定this给函数
        render(): 返回一个jsx
          1:jsx
          2:字符串
          3:null
          4:boolean
          5:fragment
        componentDidMount(){}
            component:组件
            Did:已经
            Mount:挂载  Dom
          1:获取Dom节点
          2:发送ajax请求
          3:初始定时器

        更新
          改变 state  props
          render
          componentDidUpDate
            更新Dom :
        销毁
          componentWillUnmount
          清空定时器
          中断网络请求
           内存泄漏
  旧的最常用的生命周期
     不常用


旧的声明周期不能和新的生命周期共存

新的生命周期
  挂载
  constructor()
  static getDerivedStateFromProps(nextProps)
    :取代了3个生命周期
    获取父组件传过来的Props给State
    static:静态 属于类 不属于实例
    不能调用this
    this.setState({}):失效
    return {user:nextProps.user}
  render(){}
  componentDidMount()
  更新
  static getDerivedStateFromProps()
  shouldComponentUpdate()
  render()  返回的虚拟Dom     垃圾
  getSnapshotBeforeUpdate():  垃圾清空   中断
    获取更新之前的快照
    记录虚拟Dom--->真实DOM的过程
  componentDidUpdate() 挂载到真实dom

  卸载
  当组件从 DOM 中移除时会调用如下方法：
  componentWillUnmount()



刷新
列表
数据:axios --->后台  express
请求数据 componentDidMount
刷新:  loading  2s 定时器
       componentWillUnmount
       取消网络请求

 子页:传递给子组件  list
   判断数据有没有改变 render
   改变  改变的条数

原生
1:div  onClick=aaa()

react:合成
1:div  onCLick={this.aaa}
//1: this  .bind(this)
//2:没有()

react合成事件

vue:双向绑定  v-model
ref

受控组件:
    input  value={this.state.name} onChange={(e)=>{
        this.setState({name:e})
    }}

非受控组件:

day05:
  回顾:
  生命周期:
    旧:
    挂载
    constructor
    componentWillMount
    render
    componentDidMount

    更新
    props                      state
    componentWillReceiveProps   shouldComponentUpdate(nextProps,nextState,nextContext){return boolean}
    shouldComponentUpdate       componentWillUpdate
    componentWillUpdate         render
    render                      componentDidUpdate
     返回的类型
     jsx
     Fragment
     null
     boolean
     ""
    componentDidUpdate


    销毁
    componentWillUnmount


新的:
  挂载
  static getDerivedStateFromProps
  render
  componentDidMount

  更新
  props             state                            forceUpdate:forceUpdate
  static getDerivedStateFromProps(props){
        × this
        return {num:props.num}
  }

  shouldComponentUpdate()
  render
  getSnapShotBeforeUpdate(prevProps,prevState)
  {return 记录}
  componentDidUpdate(prevProps,prevState,snapShot)
  {Dom  if(){setState({})}}


受控组件
  form
  1:
  input  value="this.state.value"  onChange={(e)=>{
    this.setState({value:e.target.value})
  }}

非受控组件
  ref
  this.refInput = React.createRef();
  input ref = {this.refInput}

  this.refInput.current.value

  ref:
    音频
    强制动画 canvas
    第三方


点击之后
  高亮

  setTimeout  0.2

  flag:boolean  true
  style={flag?{}:{}}

day06:
  回顾:
  案例
    1:受控组件
    input  value={this.state.value} onChange={(e)=>{this.setState({
        value:e.target.value
    })}}

    2:非受控
    this.aaaReaf = react.createRef();
    input ref={this.aaaRef}

    this.aaaRef.current.value

这节课:


  发布
   送饭
  订阅
   牛奶
   书
   饭


  程序:
    react

  react:
    jsx  {}  <>   React.createElement("div",null,React.createElement()...)
    组件 创建  传值
      父传子
      子传父
      计算器
    生命周期
      旧
      新
    事件 :合成事件
    受控组件 :
      form  onChange={(e)=>{this.setState({})}}
    非受控组件
      form  ref  value
    发布订阅


    路由     配置
    高阶组件 实际开发 高阶函数
    Redux    Vuex    异步actions 中间件


    复习题
      月考题

day07:
   封装组件
       按钮
       弹框
       列表
       头部

       弹框:
        1:内容 样式
        2:事件-->父组件中处理



   类型验证
   PureComponent

day08:
   回顾:
   封装组件:
     1:传参
     2:可复用


   jsx  组件 props state
   生命周期
   路由  ()
   redux

   发布订阅
   高阶组件


    路由
    高阶组件
    redux

  路由:
    干什么的?
      跳转
      切换  传值
     怎么实现?
       vue: router-view
            router-link to="/"
            router-view
       react:
            react-router

            2种方式
            React Native:  RN  app android android工程师(java) ios ios工程师 ObjectC
                  React:

day09
  回顾:
    路由
    Route:显示  path 路径   component:组件
    Link :跳转   to
    NavLink : 样式  to
    Switch:管理  Route  Redirect
    Redirect:重定向  to="/home/aaa"  exact  全部匹配
    BrowserRouter as Router: history  可以和后台交互
       根元素
    HashRouter : 静态  #

day10:
    import {BrowserRouter as Router,Link,Route,Switch}

    Router
       地址栏
       Link to="/home"  地址栏
       Route path="/home"  component=Home
       Route path="/page"  component=Page
       Route path="/me"  component=Me
       "/"  "/home"
       Redirect from=""  to="/home"

    Switch  Route Redirect
       Route path="/home"  component=Home
       Route path="/page"  component=Page
       Route path="/me"  component=Me
       Redirect


    1:配置
    RouterView   <RouterView routes={[{path:"",component},{path:"",redirect:""}]}/>
            Route path="/home"  component=Home   路由对象  render={(props)=>{}}
            Redirect from  to


    拦截:
      高阶组件

day11
    高阶组件:
    组件 = withRouter(组件)

    高阶组件:函数
            参数:组件
            返回值:组件
            xxx(组件){
                return 新的组件
            }

    1:MyComponent = 函数(MyComponent)
    2:操作方式
      1:代理
        操作props      withRouter()
        包装           弹框  吸顶  loading
        抽取状态
        ref(不常用也不推荐)
        横切关注点
        <MyComponent /> 父子



      2:继承
        生命周期  :
            数据请求
            发布 订阅

intercept
































一个房子里面有一个房间和一个洗手间，房间里面有一个人和两条狗。
请你完成组件：House，Room，Bathroom，Man，Dog，它们的最外层都用 div 标签包裹起来，类名分别为：house，room，bathroom，man，dog。
组件的实现应该具有上述的嵌套关系。





